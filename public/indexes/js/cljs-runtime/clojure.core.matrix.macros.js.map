{"version":3,"sources":["clojure/core/matrix/macros.cljc"],"mappings":"","names":[],"sourcesContent":["(ns clojure.core.matrix.macros\n  \"Namespace for core.matrix macros. Keeping them separate allows us to do conditional\n  macros that can handle the differences between Clojure and Clojurescript.\"\n  (:refer-clojure :exclude [array?]))\n\n(defmacro error\n  \"Throws an error with the provided message(s)\"\n  ([& vals]\n   `(throw (ex-info (str ~@vals) {}))))\n\n;(defmacro error\n;  \"Throws an error with the provided message(s)\"\n;  ([& vals]\n;   `(throw (#? (:clj RuntimeException.\n;                :cljs js/Error.)\n;               (str ~@vals)))))\n\n;(defmacro error?\n;  \"Returns true if executing body throws an error, false otherwise.\"\n;  ([& body]\n;    `(try\n;       ~@body\n;       false\n;       (catch #?(:clj Throwable :cljs js/Error) t#\n;         true))))\n\n;; useful TODO macro: facilitates searching for TODO while throwing an error at runtime :-)\n(defmacro TODO\n  ([] `(error \"TODO: not yet implemented\"))\n  ([& vals] `(error \"TODO: \" ~@vals)))\n\n(defmacro iae\n  \"Throws IllegalArgumentException with provided string\"\n  [exception-str]\n  `(throw (IllegalArgumentException. ~exception-str)))\n\n(defmacro iae-when-not\n  \"Throws an IllegalArgumentException when the predicate is not satisfied\"\n  [pred? exception-str]\n  `(when-not ~pred?\n     (iae ~exception-str)))\n\n(defmacro doseq-indexed\n  \"loops over a set of values, binding index-sym to the 0-based index of each value\"\n  ([[val-sym values index-sym] & code]\n  `(loop [vals# (seq ~values)\n          ~index-sym (long 0)]\n     (if vals#\n       (let [~val-sym (first vals#)]\n             ~@code\n             (recur (next vals#) (inc ~index-sym)))\n       nil))))\n\n(defmacro is-object-array? [m]\n  #?(:clj `(instance? ~(Class/forName \"[Ljava.lang.Object;\") ~m)\n     :cljs `(= js/Array (type ~m))))\n\n(defmacro is-long-array? [m]\n  #?(:clj `(instance? ~(Class/forName \"[J\") ~m)\n     :cljs `(= js/Array (type ~m))))\n\n(defmacro is-double-array? [m]\n  #?(:clj `(instance? ~(Class/forName \"[D\") ~m)\n     :cljs `(= js/Array (type ~m))))\n\n(defmacro c-for\n  \"C-like loop with nested loops support\"\n  [loops & body]\n  (letfn [(c-for-rec [loops body-stmts]\n            (if (seq loops)\n              (let [[var init check next] (take 4 loops)]\n                `((loop [~var ~init]\n                     (when ~check\n                       ~@(c-for-rec (nthrest loops 4) body-stmts)\n                       (recur ~next)))))\n              body-stmts))]\n    `(do ~@(c-for-rec loops body) nil)))\n\n(defmacro scalar-coerce\n  \"Macro to coerce to scalar value with an efficient dispatch sequence\"\n  ([x]\n  `(let [x# ~x]\n     (cond\n       (number? x#) x#\n       :else (clojure.core.matrix.protocols/get-0d x#)))))\n\n(defmacro array?\n  \"Returns true if the parameter is an N-dimensional array of any type\"\n  [m]\n  `(not (clojure.core.matrix.protocols/is-scalar? ~m)))\n\n"],"x_google_ignoreList":[0]}