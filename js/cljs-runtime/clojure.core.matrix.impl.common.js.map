{"version":3,"sources":["clojure/core/matrix/impl/common.cljc"],"mappings":"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","names":["clojure.core.matrix.impl.common/get-impl-objs","cljs.core.filter","cljs.core/second","iter__5523__auto__","s__22272","cljs.core/LazySeq","temp__5804__auto__","cljs.core/seq","cljs.core/chunked-seq?","c__5521__auto__","size__5522__auto__","cljs.core/count","b__22274","cljs.core/chunk-buffer","i__22273","vec__22275","cljs.core/-nth","cljs.core.nth","cljs.core/chunk-append","cljs.core/chunk-cons","cljs.core/chunk","iter__22271","cljs.core/chunk-rest","vec__22281","cljs.core/first","cljs.core/cons","cljs.core/rest","name","ns","clojure.core.matrix.implementations/KNOWN-IMPLEMENTATIONS","cljs.core/not","fexpr__22278","fexpr__22285","e22279","e22289","clojure.core.matrix.implementations.get_canonical_object","js/Error","t","clojure.core.matrix.impl.common/construct-matrix","impl","data","or__5045__auto__","clojure.core.matrix.protocols/construct-matrix","e22301","clojure.core.matrix.implementations/*matrix-implementation*","clojure.core.matrix.impl.common/ClassCastException","var_args","G__22322","clojure.core.matrix.impl.common/mapmatrix","args-arr__5794__auto__","len__5769__auto__","i__5770__auto__","argseq__5795__auto__","cljs.core/IndexedSeq","seq22317","G__22318","cljs.core/next","G__22319","G__22320","G__22321","self__5754__auto__","f","m","dims","cljs.core/long","clojure.core.matrix.protocols/dimensionality","G__22323","x__19479__auto__","clojure.core.matrix.protocols/get-0d","cljs.core.map","clojure.core.matrix.protocols/element-seq","res","cljs.core.partial","clojure.core.matrix.protocols/get-major-slice-seq","clojure.core.matrix.protocols/reshape","clojure.core.matrix.protocols/coerce-param","cljs.core/vec","cljs.core.concat","clojure.core.matrix.protocols/get-shape","m1","m2","G__22326","G__22327","m3","G__22331","G__22332","G__22333","cljs.core.mapv","more","cljs.core.apply","cljs.core/map","clojure.core.matrix.impl.common/logistic-fn","e-t","Math/exp","clojure.core.matrix.impl.common/softplus-fn","et","Math/log","clojure.core.matrix.impl.common/relu-fn","Math/max","clojure.core.matrix.impl.common/square?","clojure.core.matrix.protocols/dimension-count","clojure.core.matrix.impl.common/symmetric-matrix-entries?","dim","i","j","cljs.core._EQ_","clojure.core.matrix.protocols/get-2d","cljs.core/chunk-first"],"sourcesContent":["(ns clojure.core.matrix.impl.common\n  \"Namespace containing common functions useful for core.matrix implementatations\"\n  (:require [clojure.string :as s]\n            [clojure.core.matrix.protocols :as mp]\n            [clojure.core.matrix.utils :as u]\n            [clojure.core.matrix.implementations :as mi]\n    #?(:clj [clojure.java.shell :refer [sh]]))\n  (#?(:clj :require :cljs :require-macros)\n           [clojure.core.matrix.macros :refer [scalar-coerce]]))\n\n(defn get-impl-objs\n  \"Returns a list of available implementations' objects\"\n  []\n  (filter second\n          (for [[name ns] mi/KNOWN-IMPLEMENTATIONS\n                :when (not (#{:TODO :persistent-vector} ns))]\n            (try\n              {:name name, :obj (mi/get-canonical-object name)}\n              (catch #?(:clj Throwable :cljs js/Error) t nil)))))\n\n#?(:clj (do\n\n(defn find-implementers\n  \"Returns a set of implementation names of implementations that\n   support provided protocol\"\n  [protocol impl-objs]\n  (->> impl-objs\n       (filter #(->> % :obj class (u/extends-deep? protocol)))\n       (map :name)\n       (into #{})))\n\n(defn extract-implementations\n  \"Returns a a sequence of protocol maps augmented with :implemented-by key\n   that contains a set of names of supporting implementations\"\n  [protocols impl-objs]\n  (for [proto protocols]\n    (assoc proto :implemented-by (find-implementers proto impl-objs))))\n\n(defn get-git-hash\n  \"Returns current revision's git hash\"\n  []\n  (-> (sh \"git\" \"log\" \"--pretty=format:'%H'\" \"-n 1\")\n      :out\n      (s/replace #\"'\" \"\")))\n\n))\n\n(defn construct-matrix\n  \"Constructs an array from the provided data, attempting to use the given implementation.\n   Uses a default implementation if needed\"\n  ([impl data]\n    (or (mp/construct-matrix impl data)\n        (try \n          (mp/construct-matrix mi/*matrix-implementation* data)\n          (catch ClassCastException t nil)) ;; fix for element type not handled\n        (mp/construct-matrix [] data))))\n\n(defn mapmatrix\n  \"Maps a function over all components of a persistent vector matrix. Like mapv but for matrices.\n   Assumes correct dimensionality / shape.\n\n   First array argument must be nested persistent vectors. Others may be\n   any arrays of the same shape.\n\n   Returns a nested persistent vector matrix or a scalar value.\"\n  ([f m]\n   (let [dims (long (mp/dimensionality m))]\n     (cond\n       (== 0 dims) (f (scalar-coerce m))\n       (== 1 dims) (construct-matrix m\n                     (map f (mp/element-seq m)))\n       :else\n       (let [res (map (partial mapmatrix f) (mp/get-major-slice-seq m))]\n         (mp/reshape (mp/coerce-param m res)\n                     (vec (concat [(first (mp/get-shape m))] (next (mp/get-shape res)))))))))\n  ([f m1 m2]\n    (let [dims (long (mp/dimensionality m1))]\n      (cond\n        (== 0 dims) (f (scalar-coerce m1) (scalar-coerce m2))\n        (== 1 dims) (construct-matrix m1\n                      (map f (mp/element-seq m1) (mp/element-seq m2)))\n        :else\n        (let [res (map (partial mapmatrix f) (mp/get-major-slice-seq m1) (mp/get-major-slice-seq m2))]\n          (mp/reshape (mp/coerce-param m1 res)\n            (vec (concat [(first (mp/get-shape m1))] (next (mp/get-shape res)))))))))\n  ([f m1 m2 m3]\n    (let [dims (long (mp/dimensionality m1))]\n      (cond\n        (== 0 dims) (f (scalar-coerce m1) (scalar-coerce m2) (scalar-coerce m3))\n        (== 1 dims) (construct-matrix m1\n                      (map f (mp/element-seq m1) (mp/element-seq m2) (mp/element-seq m3)))\n        :else\n        (let [res (mapv (partial mapmatrix f)\n                        (mp/get-major-slice-seq m1)\n                        (mp/get-major-slice-seq m2)\n                        (mp/get-major-slice-seq m3))]\n          (mp/reshape (mp/coerce-param m1 res)\n            (vec (concat [(first (mp/get-shape m1))] (next (mp/get-shape res)))))))))\n  ([f m1 m2 m3 & more]\n    (let [dims (long (mp/dimensionality m1))]\n      (cond\n        (== 0 dims) (apply f (scalar-coerce m1) (scalar-coerce m2)\n                           (scalar-coerce m3) (map mp/get-0d more))\n        (== 1 dims) (construct-matrix m1\n                      (apply map f (mp/element-seq m1) (mp/element-seq m2)\n                             (mp/element-seq m3) (map mp/element-seq more)))\n        :else\n        (let [res (apply map (partial mapmatrix f)\n                         (mp/get-major-slice-seq m1)\n                         (mp/get-major-slice-seq m2)\n                         (mp/get-major-slice-seq m3)\n                         (map mp/get-major-slice-seq more))]\n          (mp/reshape (mp/coerce-param m1 res)\n            (vec (concat [(first (mp/get-shape m1))] (next (mp/get-shape res))))))))))\n\n(defn logistic-fn\n  \"Logistic function, with primitive type hints\"\n  (^double [^double t]\n    (let [e-t (Math/exp (- t))]\n      (/ 1.0 (+ 1.0 e-t)))))\n\n(defn softplus-fn\n  \"Softplus function, with primitive type hints\"\n  (^double [^double t]\n    (if (> t 100.0) ;; catch the case of overflow to infinity for large inputs\n      t\n      (let [et (Math/exp t)]\n        (Math/log (+ 1.0 et))))))\n\n(defn relu-fn\n  \"ReLU function, with primitive type hints\"\n  (^double [^double t]\n    (Math/max 0.0 t)))\n\n(defn square?\n  \"Returns true if matrix is square (2D with same number of rows and columns)\"\n  ([m]\n    (and\n      (== 2 (long (mp/dimensionality m)))\n      (== (long (mp/dimension-count m 0)) (long (mp/dimension-count m 1))))))\n\n;; Helper function for symmetric? predicate in PMatrixPredicates.\n;; Note loop/recur instead of letfn/recur is 20-25% slower.\n;; not possible to eliminate boxing warnings - needs to handle any numeric type\n(defn symmetric-matrix-entries?\n  \"Returns true iff square matrix m is symmetric.\"\n  [m]\n  (let [dim (long (first (mp/get-shape m)))]\n    (letfn [(f [^long i ^long j]\n              (cond\n                (>= i dim) true                         ; all entries match: symmetric\n                (>= j dim) (recur (+ 1 i) (+ 2 i))      ; all j's OK: restart with new i\n                (= (mp/get-2d m i j)\n                   (mp/get-2d m j i)) (recur i (inc j)) ; OK, so check next pair\n                :else false))]                          ; not same, not symmetric\n      (f 0 1))))\n\n"],"x_google_ignoreList":[0]}